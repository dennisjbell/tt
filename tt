#!/usr/bin/perl

use warnings;
use strict;

use POSIX qw(strftime);
use Date::Parse qw(str2time);

our $TT_FILE = "$ENV{HOME}/.timetrack";
our $VERSION = "1.0";

sub rjust
{
	my ($s, $n, $fill) = @_;
	$fill = $fill || ' ';
	return ($fill x ($n - length $s)) . $s;
}

sub mkdate
{
	my ($y,$m,$d) = @_;
	if ($y && $m && $d) {
		return sprintf("%04s-%02s-%02s", $y, $m, $d);
	}
	if ($y) { # timestamp
		return strftime("%Y-%m-%d", localtime($y));
	}
	undef;
}

sub skip_dst
{
	$_[0]+43200;
}

sub next_date
{
	return undef unless my $ts = str2time(shift);
	mkdate(skip_dst($ts+86400));
}

sub match_date_range
{
	my ($from, $to) = @_;
	return "^(".join("|", @{expand_date_range($from, $to)}).")";
}

sub expand_date_range
{
	my ($date, $end) = @_;
	my @dates = ();

	while ($date ne $end) {
		push @dates, $date;
		$date = next_date($date);
	}
	push @dates, $end;
	return \@dates;
}

sub parse_date_range
{
	my ($from, $to) = split(/:/, shift);
	$from = parse_date($from);
	return unless $from;

	return ($from, $from) unless $to;

	my $end = parse_date($to);
	return ($from, $end) if $end;

	if ($to =~ m/^\d+$/) {
		$end = next_date($from) until $end =~ m/-$to$/;
		return ($from, $end);
	}

	if ($to =~ m/^[+-]\d+$/) {
		my $ts = str2time($from);
		$end = mkdate(skip_dst($ts+($to*86400)));
		return ($to > 0 ? ($from, $end) : ($end, $from));
	}
}

sub time_stat
{
	my @st = stat $TT_FILE or return undef;
	return int((time - $st[9]) / 60 + 0.5);
}

sub parse_time
{
	my $str = shift;
	return 0 unless $str;
	return $str if $str =~ m/^\d+$/;

	if ($str eq "s") {
		return time_stat;
	}

	if ($str =~ m/^((\d+(\.\d+)?)h)?((\d+)m)?$/) {
		return ($2||0)*60 + ($5||0);
	}

	if ($str =~ m/^((\d+)m)?((\d+(\.\d+)?)h)?$/) {
		return ($4||0)*60 + ($2||0);
	}

	undef;
}

sub parse_date
{
	my $str = shift;
	if ($str =~ m/^(\d+)([dw])$/) {
		my $offset = 0;
		$offset = 86400   if $2 eq 'd';
		$offset = 86400*7 if $2 eq 'w';
		return mkdate(time-$offset*$1);
	}
	if ($str =~ m/^(\d\d\d\d)-(\d+)-(\d+)$/) {
		return mkdate($1,$2,$3);
	}

	if ($str =~ m|^(\d+)/(\d+)/(\d\d\d\d)$|) {
		return mkdate($3,$1,$2);
	}

	if ($str =~ m/^((Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))\s+(\d+)\s+(\d\d\d\d)/) {
		my %MONTHS = (
			Jan =>  1, Feb =>  2, Mar =>  3, Apr =>  4,
			May =>  5, Jun =>  6, Jul =>  7, Aug =>  8,
			Sep =>  9, Oct => 10, Nov => 11, Dec => 12
		);
		return mkdate($3,$MONTHS{$1},$2);
	}

	# FIXME: handle relative date of "last <dayname>"
}

sub track
{
	my ($date, $type, $time, $comment) = @_;
	$comment =~ s/\n/.  /;
	open TT, ">>", $TT_FILE or die "$TT_FILE: $!\n";
	print TT "$date $type ", sprintf("%3i", $time), " $comment\n";
	close TT;
}

sub extract
{
	my $regex = qr/$_[0]/;
	my $res = {};

	open TT, "<", $TT_FILE or die "$TT_FILE: $!\n";
	while (<TT>) {
		next unless $_ =~ $regex;
		chomp;
		# Key by first subgroup match
		push @{$res->{$1}}, $_;
	}

	return $res;
}

sub sum_totals
{
	my ($lines) = @_;

	my $total = {};
	for (@$lines) {
		next unless m/^\d\d\d\d-\d\d-\d\d\s+(.)\s+(\d+)/;
		next unless $2 > 0;
		$total->{$1} += $2;
	}
	return $total;
}

#########################################################

use Getopt::Long;
Getopt::Long::Configure("bundling");

sub debug1
{
	map { print STDERR "DEBUG> $_\n" } @_;
	print STDERR "\n";
}
sub debug0 { }

sub usage
{
	(my $bin = $0) =~ s|.*/||;
	print "USAGE: $bin T 99 summary of what you did\n",
	      "       $bin [OPTIONS]\n",
	      "$bin -h for help\n";
	exit shift;
}

sub help
{
	print <<EOF;
tt - dead-simple time tracking
Copyright (c) 2012 James Hunt <james\@niftylogic.com>
Based on the 'no magic' attitude of Russ Crandall

Basic Usage:
  tt [TYPE] [MINUTES] [COMMENT]
  tt

Advanced Usage:
  tt [OPTIONS]

  OPTIONS
  --help, -h
      Show this helpful help message

  --summary, -s <period>
      Report tracked time in a date range or named
      reporting period.

      Periods:   day, week, mtd
      Arbitrary: YYYY-MM-DD:YYYY-MM-DD
                 YYYY-MM-DD:+N
                 YYYY-MM-DD:DD

  --full, -f
      Show details in --summary.  Ignored otherwise.

  --date, -d YYYY-MM-DD
      Use specified date as reference point.

  --sync
      Synchronize time tracked data to central server.
      Requires more infrastructure and some config.

  --config, -C /path/to/tt.conf
      Use alternate configuration file.
      Default is ~/.ttrc, then /etc/tt.conf

EOF
}

my %opt = ();
GetOptions(\%opt,
	'help|h',
	'debug|v',     # undocumented
	'summary|s',
	'full|f',
	'date|d=s',
	'edit|e',
	'sync',        # NOT IMPL
	'mark',
	'config|C',    # NOT IMPL

	'week|w',
	'month|m',
	'range|r=s',
) or usage(1);

sub print_lines
{
	my $lines = shift;
	for (@$lines) {
		print "$_\n";
	}
	print "\n" if @$lines;
}

sub print_totals_bare
{
	my ($total) = @_;

	print " Type    Min     Hrs  \n";
	print "---------------------\n";
	my $sum = 0;
	for my $k (keys %$total) {
		print sprintf("%4s: %6i %6.1fh\n",
			$k, $total->{$k}, $total->{$k}/60.0);
		$sum += $total->{$k};
	}
	print "---------------------\n";
	print sprintf(" Sum: %6i %6.1fh\n",
		$sum, $sum/60.0);
}

sub print_totals
{
	my ($total, $expected) = @_;
	return print_totals_bare($total) unless $expected;

	print " Type    Min     Hrs        %\n";
	print "-----------------------------\n";
	my $sum = 0;
	for my $k (keys %$total) {
		print sprintf("%4s: %6i %6.1fh  %6.2f%%\n",
			$k, $total->{$k}, $total->{$k}/60.0, $total->{$k}*100.0/$expected);
		$sum += $total->{$k};
	}
	print "-----------------------------\n";
	print sprintf(" Sum: %6i %6.1fh  %6.2f%% (of %0.1fh)\n",
		$sum, $sum/60.0, $sum*100.0/$expected, $expected/60.0);
}

sub summarize
{
	my $lines = shift;
	print_lines($lines) if !$opt{summary} || $opt{full};
	print_totals(sum_totals($lines), 480);
}

*debug = $opt{debug} ? \&debug1 : \&debug0;

if ($opt{help}) {
	help;
	exit 0;
}

debug("tt v$VERSION starting up");

if ($opt{config}) {
	print STDERR "warning: config is not yet implemented.\n";
	exit 1;
}

if ($opt{edit}) {
	exec '/bin/sh -c "$EDITOR '.$TT_FILE.'"';
}

if ($opt{mark}) {
	my $comment = join(" ", @ARGV);
	track(mkdate(time), "a", 0, "ttmark: $comment");
	exit 0;
}

# Set the reference point date
#
if (exists $opt{date}) {
	my $date = parse_date($opt{date});
	$date or die "$opt{date}: not a valid date spec.\n";
	$opt{date} = $date;
} else {
	$opt{date} = mkdate(time);
}

if ($opt{sync}) {
	print STDERR "warning: sync is not implemented yet.\n";
	exit 1;
}

# Date range of summary
my ($from, $to);

# Process named summation periods
#
my $period = "custom";
my $expect = undef;
if ($opt{month}) {
	$period = "month";
	$opt{date} =~ m/(\d+)$/;
	my $mday = $1-1;
	($from, $to) = parse_date_range("$opt{date}:-$mday");

} elsif ($opt{week}) {
	$period = "week";
	$expect = 2400; # minutes in a 40h week
	($from, $to) = parse_date_range("$opt{date}:-7");

} elsif ($opt{range}) {
	($from, $to) = parse_date_range($opt{range});

} else {
	$expect = 480; # minutes in an 8 hour day
	($from, $to) = ($opt{date}, $opt{date});
}

debug("summary period is $period");
debug("from: $from", "to:   $to");

if ($opt{summary}) {

	print "Time Tracking Report\n";
	if ($from eq $to) {
		print "  for $from\n\n";
	} else {
		print "  $from - $to\n\n";
	}
	my $dates = expand_date_range($from, $to);
	my $log = extract(match_date_range($from, $to));

	my $grand_total = {};
	for (@$dates) {
		my $total = sum_totals($log->{$_});
		for (keys %$total) {
			$grand_total->{$_} += $total->{$_};
		}
		print_lines($log->{$_}) if $opt{full};
	}
	print_totals($grand_total, $expect);
	exit 0;
}

debug("\@argv == ".@ARGV);
debug(map { "argv[]: $_" } @ARGV);

if (@ARGV == 0) {
	my $lines = extract("^($opt{date})\\s");
	summarize($lines->{$opt{date}});
	print "\n";

	my $since = time_stat;
	defined($since) and print rjust(" updated $since min. ago ---\n", 30, '-');
	exit 0;

} elsif (@ARGV >= 3) {
	my ($type, $time_s, @rest) = @ARGV;
	my $comment = join(" ", @rest);

	my $time = parse_time($time_s);
	if (!$time) {
		die "$time_s: does not look like a valid time spec\n";
	}

	track($opt{date}, $type, $time, $comment);
	exit 0;

} else {
	usage(1);
}

